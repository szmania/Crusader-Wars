# Plan to Fix Autofixer Unit Replacement

## 1. Summary / Overview

The current autofixer unit replacement strategy is unreliable. It often fails to find suitable replacement units, sometimes replaces only a single instance of a problematic unit instead of all of them, and can fail to apply any fix at all. This is because the logic for finding a replacement is fragile and the state management is overly complex.

The goal is to rework the unit replacement logic to be more robust. The new logic will ensure that when a problematic Attila unit key is identified, a valid replacement is found by systematically searching through heritage-related factions and then a default pool. Once found, the fix will be applied universally to all units that map to the problematic key.

## 2. Design Requirements

- The system must correctly identify all unique, non-vanilla Attila unit keys from all armies in the battle as potential problems.
- The system must iterate through these problematic keys one at a time for each autofix attempt.
- For a given problematic key, the system must find a suitable replacement that is not the same as the problematic key.
- The replacement search must first try factions within the same cultural heritage as a representative original unit.
- If no heritage replacement is found, the system must fall back to finding a suitable default unit.
- The replacement unit must be of the same general type (e.g., a commander replaces a commander, a knight replaces a knight).
- Once a replacement key is determined, *all* units that would have originally mapped to the problematic key must now map to the new replacement key for the subsequent battle attempt.

## 3. Design Specification

The fix involves two main parts: simplifying the control flow in `BattleProcessor.cs` and making the unit-finding logic in `UnitMappers_BETA.cs` more robust by preventing a unit from being replaced by itself.

### `CrusaderWars/twbattle/BattleProcessor.cs`

- **`AutofixState` Class:** The `HeritageReplacementFactions` and `NextHeritageFactionIndex` properties will be removed, as they are part of the overly complex state management that is being replaced.
- **`TryUnitFix` Method:** This method will be completely rewritten with a simpler, more direct logic:
    1.  It will loop through the `ProblematicUnitKeys` list, starting from the index of the last attempt.
    2.  For each `keyToReplace`, it will find a single `representativeUnit` to provide context (heritage, rank, type).
    3.  It will build a list of potential replacement factions, starting with factions from the same heritage and ending with the "Default" faction as a fallback.
    4.  It will iterate through this list of factions, calling `UnitMappers_BETA.GetReplacementUnitKeyFromFaction` and `UnitMappers_BETA.GetDefaultUnitKey` to find a valid replacement. Crucially, it will pass the `keyToReplace` to these functions to ensure the same key isn't returned.
    5.  The first valid replacement found will be stored in the `AutofixReplacements` dictionary, and the method will immediately return `true`.
    6.  If no replacement is found for the current `keyToReplace` after checking all possibilities, the loop will continue to the next problematic key.
    7.  If the entire list of problematic keys is exhausted with no replacement found, the method will return `false`.

### `CrusaderWars/unit_mapper/UnitMappers_BETA.cs`

- Several methods will be updated to accept an optional `keyToExclude` parameter. This prevents the autofixer from selecting the problematic unit as its own replacement.
- **`GetReplacementUnitKeyFromFaction(..., string? keyToExclude = null)`**: Will be updated to accept and pass down the parameter.
- **`GetDefaultUnitKey(..., string? keyToExclude = null)`**: Will be updated to accept and pass down the parameter.
- **`FindUnitKeyInFaction(..., string? keyToExclude = null)`**: Will be updated to check against `keyToExclude` before returning a Men-At-Arms key. It will pass the parameter down to `SelectRankedUnitKey`.
- **`SelectRankedUnitKey(..., string? keyToExclude = null)`**: Will be updated to filter out the `keyToExclude` from its list of candidates before making a selection.

## 4. Implementation Steps

- [ ] **1. Modify `UnitMappers_BETA.cs` to prevent self-replacement:**
    - [ ] 1.1. Update the signature of `GetDefaultUnitKey` to accept `string? keyToExclude = null`.
    - [ ] 1.2. Update the signature of `GetReplacementUnitKeyFromFaction` to accept `string? keyToExclude = null`.
    - [ ] 1.3. Update the signature of `FindUnitKeyInFaction` to accept `string? keyToExclude = null`.
    - [ ] 1.4. Update the signature of `SelectRankedUnitKey` to accept `string? keyToExclude = null`.
    - [ ] 1.5. In `SelectRankedUnitKey`, add logic to filter out the `keyToExclude` from the `candidates` list.
    - [ ] 1.6. In `FindUnitKeyInFaction`, pass `keyToExclude` to `SelectRankedUnitKey` and add a manual check for Men-At-Arms.
    - [ ] 1.7. In `GetDefaultUnitKey`, pass `keyToExclude` to helpers and filter candidate lists.
    - [ ] 1.8. In `GetReplacementUnitKeyFromFaction`, pass `keyToExclude` to `FindUnitKeyInFaction`.

- [ ] **2. Refactor `BattleProcessor.cs` for simpler, more robust logic:**
    - [ ] 2.1. In the `AutofixState` class, remove the `HeritageReplacementFactions` and `NextHeritageFactionIndex` properties.
    - [ ] 2.2. Replace the entire body of the `TryUnitFix` method with the new, simplified logic described in the Design Specification.
    - [ ] 2.3. Update the calls to `GetReplacementUnitKeyFromFaction` and `GetDefaultUnitKey` within the new `TryUnitFix` to pass `keyToReplace` as the `keyToExclude` argument.

## 5. Clarifying Questions

There are no clarifying questions at this time. The plan is comprehensive and directly addresses the user's reported issues by improving the robustness of the replacement search and simplifying the overall control flow.

## 6. Assumptions

- The `AutofixReplacements` dictionary mechanism, which applies the fix during the battle regeneration, is fundamentally sound. The primary issue is the failure to populate it with a valid replacement.
- The unit mapper XML files contain a sufficient variety of units in heritage and default factions to serve as viable replacements.
