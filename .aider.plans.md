# Development Plan: Attila Crash Detection and Autofix

## 1. Summary / Overview
- **Problem**: Total War: Attila frequently crashes when loading battles with custom units from the extensive unit mappers or due to issues with map deployments. This creates a poor user experience, forcing users to manually restart the process without a clear solution.
- **Goal**: Implement an automatic crash detection and recovery system that can address both unit and deployment issues.
- **Outcome**: When Attila crashes, the application will detect it, inform the user, and offer an iterative autofix. The system will alternate between replacing one potentially problematic unit type at a time with a safe default and adjusting the battle map size/layout, then relaunch the battle. This dual-pronged approach will significantly improve stability and help identify the specific cause of crashes.

## 2. Design Requirements
- The system must reliably detect when the Attila process terminates prematurely.
- Upon the first crash, the user must be presented with a clear dialog box explaining the likely causes and offering the autofix.
- The autofix process must be iterative and alternate between two types of fixes:
    1.  **Unit Fix**: Replace only one unique Attila unit key across all armies per attempt.
    2.  **Deployment Fix**: Systematically change the battle map size and deployment orientation.
- The unit fix should not affect core units like Generals and Knights.
- If the user agrees, the battle should be regenerated and relaunched seamlessly.
- If a subsequent crash occurs during the autofix sequence, the user should not be prompted again. The system should automatically proceed to the next fix in the sequence.
- The system must prevent infinite loops if the autofix process fails after all potential unit and deployment fixes have been tried.

## 3. Design Specification
- **Files to Modify**: `CrusaderWars\twbattle\BattleProcessor.cs`, `CrusaderWars\twbattle\BattleState.cs`, `CrusaderWars\terrain\Deployments.cs`.
- **New Helper Class (`BattleProcessor.cs`)**: A private class `AutofixState` will manage the iterative fix process.
    - `public List<string> ProblematicUnitKeys { get; set; }` // A list of unique Attila unit keys to test.
    - `public int NextUnitKeyIndexToReplace { get; set; }` // The index of the next key in the list to replace.
    - `public int NextDeploymentFixLevel { get; set; }` // An integer (1-5) representing the next deployment configuration to try.
    - `public bool IsNextFixUnitReplacement { get; set; }` // A flag to control the alternating sequence.
- **New Static Properties (`BattleState.cs`)**:
    - `public static string? AutofixDeploymentSizeOverride { get; set; }`
    - `public static bool? AutofixDeploymentRotationOverride { get; set; }`
    - These will be used to temporarily override deployment settings during an autofix attempt.
- **Logic Flow (`ProcessBattle` method):**
    1.  The `while (battleEnded == false)` loop detects a crash when `Process.GetProcessesByName("Attila").Length == 0`.
    2.  **If `autofixState` is `null` (First Crash):**
        - Show the `MessageBox` to the user explaining the autofix process for both units and deployments.
        - If "Yes", create a new `AutofixState` instance and populate the list of problematic unit keys.
    3.  **Autofix Logic (for all crashes in the sequence):**
        - Check if both unit and deployment fixes have been exhausted. If so, inform the user and fail.
        - Check `autofixState.IsNextFixUnitReplacement`.
        - If it's time for a unit fix and there are units left to try, apply it:
            - Replace the next unit key in the list with a safe default.
            - Increment `NextUnitKeyIndexToReplace` and toggle `IsNextFixUnitReplacement` to `false`.
        - Else, if it's time for a deployment fix and there are deployment levels left to try, apply it:
            - Use `NextDeploymentFixLevel` to set the `AutofixDeployment...Override` properties in `BattleState`.
            - The `Deployments.cs` logic will pick up these overrides.
            - Increment `NextDeploymentFixLevel` and toggle `IsNextFixUnitReplacement` to `true`.
        - If the preferred fix type is exhausted, the logic will attempt the other type.
        - Recursively call `ProcessBattle(..., autofixState)` to regenerate the battle files and relaunch Attila with the new fix applied.

## 4. Implementation Steps
- [x] 1. Modify `CrusaderWars\twbattle\BattleState.cs`.
    - [x] 1.1. Add `AutofixDeploymentSizeOverride` and `AutofixDeploymentRotationOverride` static properties.
    - [x] 1.2. Add a `ClearAutofixOverrides()` method and call it from `ClearBattleState()`.
- [x] 2. Modify `CrusaderWars\terrain\Deployments.cs`.
    - [x] 2.1. In the `DeploymentArea` constructor, check for `BattleState.AutofixDeploymentSizeOverride` and use it in place of the normal map size option if it exists.
    - [x] 2.2. In `beta_SetSidesDirections`, check for `BattleState.AutofixDeploymentRotationOverride` and use it to determine deployment rotation if it exists.
- [x] 3. Modify `CrusaderWars\twbattle\BattleProcessor.cs`.
    - [x] 3.1. Update the `AutofixState` class with `NextDeploymentFixLevel` and `IsNextFixUnitReplacement` properties.
    - [x] 3.2. At the start of `ProcessBattle`, clear any lingering autofix overrides from a previous run.
    - [x] 3.3. In the crash detection block, update the user prompt `MessageBox` to explain the new alternating fix strategy.
    - [x] 3.4. When initializing `autofixState` for the first time, set the new properties to their initial values.
    - [x] 3.5. Implement the core alternating fix logic that decides whether to perform a unit or deployment fix based on the `AutofixState`.
    - [x] 3.6. Implement the deployment fix logic, which uses a switch statement on `NextDeploymentFixLevel` to set the static override properties in `BattleState`.
    - [x] 3.7. Update the termination logic to fail only when both unit and deployment fixes have been exhausted.
    - [x] 3.8. Ensure the recursive call to `ProcessBattle` correctly passes the updated `autofixState`.

## 5. Clarifying Questions
- The user has confirmed the alternating "back and forth" strategy. No further questions.

## 6. Feedback and Iteration
- This plan incorporates the user's request to add deployment adjustments to the autofix routine, creating a more robust crash recovery system.

## 7. Assumptions
- The `UnitMappers_BETA.GetDefaultUnitKey()` method will consistently return a valid, non-crashing unit key.
- Crashes are primarily caused by specific unit models or deployment configurations.
- The crash occurs while the application is waiting for the Attila battle to complete.
