# Plan to Fix Autofixer Unit Replacement

## 1. Summary / Overview

The current autofixer unit replacement strategy is unreliable and its control flow is rigid. It often fails to find suitable replacement units, sometimes replaces only a single instance of a problematic unit, and can fail to apply any fix at all. Furthermore, once a fix strategy is chosen, it automatically cycles through all other strategies without user input, which can be time-consuming and undesirable.

The goal is to rework the autofixer with two key improvements:
1.  Make the unit replacement logic more robust by ensuring a valid, different replacement unit is always found.
2.  Change the control flow to be more interactive. After a chosen strategy (e.g., "Change Units") is fully attempted and fails, the user will be prompted again to select from the remaining, untried strategies.

## 2. Design Requirements

- The system must correctly identify all unique, non-vanilla Attila unit keys from all armies in the battle as potential problems.
- The system must iterate through these problematic keys one at a time for each autofix attempt.
- For a given problematic key, the system must find a suitable replacement that is not the same as the problematic key.
- The replacement search must first try factions within the same cultural heritage as a representative original unit.
- If no heritage replacement is found, the system must fall back to finding a suitable default unit.
- The replacement unit must be of the same general type (e.g., a commander replaces a commander, a knight replaces a knight).
- Once a replacement key is determined, *all* units that would have originally mapped to the problematic key must now map to the new replacement key for the subsequent battle attempt.
- **New:** After a chosen strategy is fully attempted and fails, the user must be prompted again to select from the remaining, untried strategies.

## 3. Design Specification

The fix involves changes to `UnitMappers_BETA.cs` to make the unit search more robust, and a significant refactoring of the control flow and state management in `BattleProcessor.cs`.

### `CrusaderWars/unit_mapper/UnitMappers_BETA.cs`

- Several methods will be updated to accept an optional `keyToExclude` parameter. This prevents the autofixer from selecting the problematic unit as its own replacement.
- **`GetReplacementUnitKeyFromFaction(..., string? keyToExclude = null)`**: Will be updated to accept and pass down the parameter.
- **`GetDefaultUnitKey(..., string? keyToExclude = null)`**: Will be updated to accept and pass down the parameter.
- **`FindUnitKeyInFaction(..., string? keyToExclude = null)`**: Will be updated to check against `keyToExclude` before returning a Men-At-Arms key. It will pass the parameter down to `SelectRankedUnitKey`.
- **`SelectRankedUnitKey(..., string? keyToExclude = null)`**: Will be updated to filter out the `keyToExclude` from its list of candidates before making a selection.

### `CrusaderWars/twbattle/BattleProcessor.cs`

- **`AutofixState` Class:** The state management will be simplified.
    - `StrategyOrder`, `CurrentStrategyIndex`, `HeritageReplacementFactions`, and `NextHeritageFactionIndex` will be removed.
    - A new property `public AutofixStrategy? CurrentStrategy { get; set; } = null;` will be added to track the active strategy.
    - A new property `public HashSet<AutofixStrategy> TriedStrategies { get; set; } = new HashSet<AutofixStrategy>();` will be added to track which strategies have been exhausted.
- **`TryUnitFix` Method:** This method will be completely rewritten with a simpler, more direct logic as described in the original plan, ensuring it finds a valid replacement and applies it universally.
- **`ProcessBattle` Method (Crash Handling Logic):** The automatic strategy-switching loop will be replaced with a more intelligent, state-driven loop.
    1.  When a crash occurs, the system will check if a `CurrentStrategy` is active in the `AutofixState`.
    2.  If a strategy is active, it will attempt a fix using the corresponding `Try...Fix` method.
    3.  If a fix is successfully applied, the battle is relaunched. The `CurrentStrategy` remains active for the next potential crash.
    4.  If the `Try...Fix` method fails (returns `false`), it means the `CurrentStrategy` is exhausted. The `CurrentStrategy` is set to `null`.
    5.  If `CurrentStrategy` is `null` (either initially, or after a strategy was exhausted), the system determines the list of available, untried strategies.
    6.  It then calls `ShowAutofixStrategyChoicePrompt` with only the available options.
    7.  The user's new choice becomes the `CurrentStrategy`, and the process repeats until a fix is found or all strategies are exhausted.
- **`ShowAutofixStrategyChoicePrompt` Method:**
    - The signature will be changed to `ShowAutofixStrategyChoicePrompt(IWin32Window owner, List<AutofixStrategy> availableStrategies)`.
    - The method will be updated to dynamically show only the radio buttons for the strategies passed in `availableStrategies`. It will position the visible controls neatly and resize the form accordingly.
    - The first strategy in the `availableStrategies` list will be selected by default.

## 4. Implementation Steps

- [x] **1. Modify `UnitMappers_BETA.cs` to prevent self-replacement:**
    - [x] 1.1. Update the signature of `GetDefaultUnitKey` to accept `string? keyToExclude = null`.
    - [x] 1.2. Update the signature of `GetReplacementUnitKeyFromFaction` to accept `string? keyToExclude = null`.
    - [x] 1.3. Update the signature of `FindUnitKeyInFaction` to accept `string? keyToExclude = null`.
    - [x] 1.4. Update the signature of `SelectRankedUnitKey` to accept `string? keyToExclude = null`.
    - [x] 1.5. In `SelectRankedUnitKey`, add logic to filter out the `keyToExclude` from the `candidates` list.
    - [x] 1.6. In `FindUnitKeyInFaction`, pass `keyToExclude` to `SelectRankedUnitKey` and add a manual check for Men-At-Arms.
    - [x] 1.7. In `GetDefaultUnitKey`, pass `keyToExclude` to helpers and filter candidate lists.
    - [x] 1.8. In `GetReplacementUnitKeyFromFaction`, pass `keyToExclude` to `FindUnitKeyInFaction`.

- [x] **2. Refactor `BattleProcessor.cs` for new autofix control flow and robust unit fixing:**
    - [x] 2.1. In the `AutofixState` class, replace old state properties (`StrategyOrder`, etc.) with `CurrentStrategy` and `TriedStrategies`.
    - [x] 2.2. Replace the entire body of the `TryUnitFix` method with the new, simplified logic.
    - [x] 2.3. In `ProcessBattle`, replace the entire crash-handling block with the new state-driven, re-prompting loop described in the Design Specification.

- [x] **3. Update UI Prompt in `BattleProcessor.cs`:**
    - [x] 3.1. Modify the signature of `ShowAutofixStrategyChoicePrompt` to accept a list of available strategies.
    - [x] 3.2. Implement logic to dynamically show/hide and reposition the strategy radio buttons and labels based on the provided list.
    - [x] 3.3. Ensure the form height is adjusted to fit the visible controls.
    - [x] 3.4. Ensure the first available option in the list is checked by default.

## 5. Clarifying Questions

There are no clarifying questions at this time. The plan is comprehensive and directly addresses the user's reported issues by improving the robustness of the replacement search and simplifying the overall control flow.

## 6. Assumptions

- The `AutofixReplacements` dictionary mechanism, which applies the fix during the battle regeneration, is fundamentally sound. The primary issue is the failure to populate it with a valid replacement.
- The unit mapper XML files contain a sufficient variety of units in heritage and default factions to serve as viable replacements.
