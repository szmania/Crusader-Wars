# Development Plan: Attila Crash Detection and Autofix

## 1. Summary / Overview
- **Problem**: Total War: Attila frequently crashes when loading battles with custom units from the extensive unit mappers. This creates a poor user experience, forcing users to manually restart the process without a clear solution.
- **Goal**: Implement an automatic crash detection and recovery system.
- **Outcome**: When Attila crashes, the application will detect it, inform the user of the likely cause (a faulty custom unit), and offer to automatically replace potentially problematic units with safe defaults. If the user agrees, the application will regenerate the battle and relaunch Attila, significantly improving stability and user satisfaction.

## 2. Design Requirements
- The system must reliably detect when the Attila process terminates prematurely (i.e., without generating a complete battle results log).
- Upon detecting a crash, the user must be presented with a clear dialog box explaining the likely cause.
- The dialog must offer the user a choice to either attempt an automatic fix or cancel and return to the main screen.
- The automatic fix must not alter the core army composition (soldier counts, number of regiments) but only swap the mapped Attila unit models for safer alternatives.
- The fix should not affect core units like Generals and Knights, which are generally stable and less likely to cause crashes.
- If the user agrees to the fix, the battle should be regenerated and Attila relaunched seamlessly.

## 3. Design Specification
- **File to Modify**: `CrusaderWars\twbattle\BattleProcessor.cs`
- **Method to Modify**: `ProcessBattle`
- **Logic Flow**:
    1.  The `while (battleEnded == false)` loop contains a check: `if (Process.GetProcessesByName("Attila").Length == 0)`. This block is triggered when the Attila process disappears.
    2.  This `if` block will be modified to show a `MessageBox` on the main UI thread.
        - **Message**: "It appears Total War: Attila has crashed or was closed prematurely. This is often caused by a custom unit that is incompatible with the game. Would you like to attempt an automatic fix by replacing all custom units with safe, default units and restarting the battle?"
        - **Buttons**: `YesNo`
        - **Icon**: `Question`
    3.  **If User Selects "Yes"**:
        - A new private helper method, `ApplySafeUnitFix(List<Army> armies)`, will be called for both attacker and defender army lists.
        - This method will iterate through all units. For each `Unit` of type `MenAtArms`, `Levy`, or `Garrison`, it will replace its current Attila unit key with a safe fallback by calling `UnitMappers_BETA.GetDefaultUnitKey(unit.GetRegimentType())`.
        - After the units are modified, `ProcessBattle` will be called recursively with the updated army lists to regenerate and relaunch the battle.
    4.  **If User Selects "No"**:
        - The application will log the user's choice and return to the main screen, preserving the original behavior for a cancelled operation.

## 4. Implementation Steps
- [ ] 1. Modify `CrusaderWars\twbattle\BattleProcessor.cs`.
- [ ] 1.1. Locate the `while (battleEnded == false)` loop within the `ProcessBattle` method.
- [ ] 1.2. Find the `if (Process.GetProcessesByName("Attila").Length == 0)` block.
- [ ] 1.3. Inside this block, replace the existing logic with a user prompt using `MessageBox.Show`.
    - [ ] 1.3.1. Ensure the `MessageBox` is invoked on the UI thread (e.g., `form.Invoke(...)`).
    - [ ] 1.3.2. The message should clearly explain the situation and offer the autofix option with "Yes" and "No" buttons.
- [ ] 1.4. If the user chooses "No", log the decision and `return false` to exit the battle loop.
- [ ] 1.5. If the user chooses "Yes", implement the autofix logic:
    - [ ] 1.5.1. Log that the user has initiated the autofix.
    - [ ] 1.5.2. Iterate through the `attacker_armies` and `defender_armies` lists.
    - [ ] 1.5.3. For each army, iterate through its `Units` list.
    - [ ] 1.5.4. For each `Unit`, check if its `RegimentType` is `MenAtArms`, `Levy`, or `Garrison`.
    - [ ] 1.5.5. If it is, call `UnitMappers_BETA.GetDefaultUnitKey()` to get a safe fallback key.
    - [ ] 1.5.6. Update the unit's key using `unit.SetUnitKey()`. Log the change from the old key to the new key for debugging purposes.
- [ ] 1.6. After modifying all necessary units, recursively call `ProcessBattle(form, attacker_armies, defender_armies, token, true)`.
- [ ] 1.7. Return the boolean result of the recursive call to correctly propagate the final status.

## 5. Clarifying Questions
- Should we add a mechanism to prevent an infinite loop if the autofix itself causes a crash (e.g., if the default units in a mapper are also broken)? A simple flag passed to the recursive call could prevent a second autofix attempt.

## 6. Feedback and Iteration
- The plan to use a recursive call is clean and reuses the existing battle generation logic effectively. The use of `GetDefaultUnitKey` is efficient. The potential for an infinite loop is the main concern and should be addressed.

## 7. Assumptions
- The `UnitMappers_BETA.GetDefaultUnitKey()` method will consistently return a valid, non-crashing unit key.
- Crashes are primarily caused by `MenAtArms`, `Levy`, or `Garrison` unit models, and not by `Commander` or `Knight` units.
- The crash occurs while the application is waiting for the Attila battle to complete, not during the initial file generation phase.
