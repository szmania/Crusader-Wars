# Crusader Conflicts - Siege Battle Implementation Plan

This plan outlines the necessary steps to implement siege battles, building upon the existing foundational code.

## 1. Overview of Siege Data Flow

### CK3 Data Acquisition for Sieges

To generate a detailed and accurate siege battle in Total War: Attila, Crusader Conflicts will use a two-pronged approach for data acquisition, combining real-time log parsing with deeper save file analysis.

**A. Real-Time Siege State from CK3 Log (`console_history.txt`):**

When the player initiates a battle from the in-game siege window, the CK3 mod logs a detailed snapshot of the current siege status to `console_history.txt`. This log is the primary source for dynamic, real-time information. The C# application will parse this log to extract:

*   **Battle Type:** The presence of the unique keyword `Keyword:CRUSADERCONFLICTS_SIEGE` at the end of the log block is the definitive trigger that identifies the combat as a siege battle.
*   **Holding Type:** The log provides the key for the primary holding building (e.g., `Holding Level:castle_01`). This is used to determine the base settlement level.
*   **Garrison Information:** The log contains the garrison's total size, culture, and heritage (e.g., `Garrison Size:565`, `Garrison Culture: armenian`, `Garrison Heritage: byzantine_heritage`).
*   **Wall Breach, Supply & Sickness Status:** The log provides frame numbers (e.g., `BreachFrame:0`, `StarvationFrame:1`, `DiseaseFrame:2`) that correspond to the state of the settlement's defenses and garrison's condition. These will be mapped to descriptive states (e.g., "Intact", "Running Low", "Rampant Disease").
*   **Attacker Army Composition:** The attacker's complete army composition is logged, which is used to identify siege weapons and generate the attacking army in Attila.

**B. Static Province Data from CK3 Save File:**

While the log provides the immediate state, the full context of the holding requires reading the main CK3 save file. Using the Province ID obtained from the initial battle log, the application will perform a targeted search within the save file's `provinces={...}` block to retrieve static data that doesn't change during the siege:

*   **Full Buildings List:** The complete list of all building keys (e.g., `type="barracks_01"`) within the province. This is essential for calculating defensive boosts and determining the settlement's visual variation (military vs. civic).
*   **Province Culture:** The culture of the province itself, used to determine the architectural style of the settlement in Attila (e.g., "Norse" culture maps to "germanic" architecture).
*   **Fort Level:** The numerical `fort_level=X` value, which provides a direct bonus to the final settlement level calculation, representing the overall defensiveness of the province.

These three data points—holding type, building list, and fort level—are combined to calculate a final numerical "level" for the settlement, which directly translates to its size and complexity in the generated Total War: Attila battle.

## 2. Total War: Attila Battle File Generation

This process remains the same as for field battles but with siege-specific modifications. The application will generate a `tut_battle.xml` file with siege parameters and a `tut_declarations.lua` file for scripting. Key differences for sieges include:
*   Setting the battle type to `settlement_standard` or `settlement_unfortified`.
*   Defining a settlement level (`<tile_upgrade>level1</tile_upgrade>`).
*   Adding escalation levels based on wall breaches (`<tile_upgrade>escalation3</tile_upgrade>`).
*   Including attacker assault equipment (e.g., `<assault_equipment_item equipment_name="battering_ram_heavy">`).
*   Declaring defender supply levels for Lua scripting.
*   Setting the defender's subculture (e.g. `<subculture>att_sub_cult_roman_west</subculture>`).

## 3. Siege Result Processing (Attila -> CK3)

The process of returning siege battle results to Crusader Kings 3 leverages the same robust system already established for field battles. The application does not need to manually script the transfer of a holding; it only needs to report the battle's outcome accurately to the CK3 engine.

*   **Outcome Determination:** After the Total War: Attila battle concludes, the application parses the Attila log file (`BattleResults_log.txt`) to determine the winner. The `BattleResult.cs` class contains the logic to identify whether the attacker or defender was victorious.

*   **Save File Modification:**
    *   **Victory/Defeat:** The application locates the corresponding `combat` entry within the CK3 save file data. It then modifies the `outcome` field to reflect an attacker victory or defeat.
    *   **Settlement Capture:** If the attacker is marked as the winner, the CK3 game engine will automatically process this upon loading the `battle_results.ck3` save. This includes transferring control of the besieged holding to the attacker and concluding the siege.
    *   **Casualties:** The application calculates casualties for every regiment involved (including the defending garrison) based on the remaining soldier counts in the Attila log. These updated numbers are written back into the `regiments` and `army_regiments` blocks of the save file.

*   **Existing Infrastructure:** This entire process is handled by the existing methods within `BattleResult.cs` and `Writter.cs`. No new major components are required to handle siege results; the existing logic is applied to the siege combat scenario.

## 4. Current Implementation Status

The foundational code for reading logs, parsing save files, and generating battle files for field battles is already in place. The `Sieges.cs` and `Sieges_DataTypes.cs` files contain placeholder structures and logic that need to be populated with the data extracted during this implementation.

## 5. Prerequisites

*   The CK3 mod must be correctly logging siege information to `console_history.txt` upon battle initiation.
*   The C# application must have access to both the log file and the CK3 save file.

## 6. Implementation Steps

### Phase 1: Data Extraction & Logic Integration

- [x] 1. **Identify Siege Battles:** In `MainFile.cs`, after `DataSearch.Search(log)`, add logic to parse the log file for the presence of the string `Keyword:CRUSADERCONFLICTS_SIEGE`. If found, set a new boolean flag `BattleState.IsSiegeBattle = true`.

- [x] 2. **Activate Province Data Scraping:**
    - [x] 2.1. In `CrusaderWars\data\save_file\Reader.cs`, inside the `ReadFile` method, ensure the conditional block `if (twbattle.BattleState.IsSiegeBattle && !string.IsNullOrEmpty(BattleResult.ProvinceID))` is active and correctly calls `GetterKeys.ReadProvinceBuildings(line, BattleResult.ProvinceID)`.
    - [x] 2.2. This will use the Province ID found in the log to scrape the save file for the full building list, province culture, and fort level.

- [x] 3. **Implement Log Parsing for Siege State:**
    - [x] 3.1. In `DataSearch.cs`, enhance the `Search` method to parse the `console_history.txt` content when a siege is detected.
    - [x] 3.2. This method must extract and store the following values:
        - [x] 3.2.1. The holding type key from the `Holding Level:` line.
        - [x] 3.2.2. The frame number from the `BreachFrame:` line. Map this number to a string: 0="Intact", 1="SmallBreach", 2="LargeBreach".
        - [x] 3.2.3. The frame number from the `StarvationFrame:` line. Map this to a string: 0="Fully Stocked", 1="Running Low", 2="Starvation".
        - [x] 3.2.4. The frame number from the `DiseaseFrame:` line. Map this to a string: 0="No Diseases", 1="Sickness Spreading", 2="Rampant Disease".
        - [x] 3.2.5. The garrison culture and heritage from the `Garrison Culture:` and `Garrison Heritage:` lines.
        - [x] 3.2.6. The garrison size from the `Garrison Size:` line.
        - [x] 3.2.7. The attacker's army composition string.

- [x] 4. **Populate Siege Data Model & Calculate Settlement Level:**
    - [x] 4.1. In `MainFile.cs`, if `BattleState.IsSiegeBattle` is true, call methods in `Sieges.cs` to set the data parsed from the log (Escalation, Supplies, Sickness, Garrison info).
    - [x] 4.2. The province culture and fort level are already set during the save file read in `Reader.cs`.
    - [x] 4.3. Modify `Sieges.cs` and `Sieges_DataTypes.cs`:
        - [x] 4.3.1. The `Sieges_DataTypes.Holding.GetLevel` method must be updated to accept the `fort_level` as a parameter.
        - [x] 4.3.2. The final level calculation within `GetLevel` should be: `base level from holding type + building wall boost + fort level`.
    - [x] 4.4. In `MainFile.cs`, call `Sieges.SetHoldingLevel`. This method will now internally use the holding key (from log), the full building list (from save), and the fort level (from save) to calculate and store the final settlement size for Attila.

- [x] 5. **Generate Garrison Army:**
    - [x] 5.1. Create a new method (e.g., in a new `GarrisonGenerator.cs` class) to create the garrison army composition.
    - [x] 5.2. This method will take the garrison size, culture, and heritage as input.
    - [x] 5.3. It will use the existing unit mapper logic to generate a list of culturally and technologically appropriate `Regiment` objects (e.g., basic levies, archers) until the total soldier count matches the garrison size. This generated army will represent the defender inside the settlement.

### Phase 2: Siege Battle File Generation

- [x] 1. **Modify `BattleFile.cs`:**
    - [x] 1.1. Add a condition: if `BattleState.IsSiegeBattle` is true, determine the battle type based on the calculated `HoldingLevel` from `Sieges.cs`.
        - [x] 1.1.1. If `HoldingLevel > 1`, set the `<type>` tag in `tut_battle.xml` to `settlement_standard`.
        - [x] 1.1.2. If `HoldingLevel <= 1`, set the `<type>` tag to `settlement_unfortified`.
    - [x] 1.2. Add the `<subculture>` tag to `tut_battle.xml`.
        - [x] 1.2.1. A new method will be needed in the unit mapper logic (e.g., `UnitMappers_BETA.cs`) to retrieve the subculture for a given faction. This method will parse the loaded `*_Factions.xml` file with the following logic:
            - [x] 1.2.1.1. Search for the `subculture` attribute within the specific faction's XML node (e.g., `<Faction name="att_fact_ghassanids" subculture="att_sub_cult_eastern_roman">`).
            - [x] 1.2.1.2. If the attribute is not found for the specific faction, search for the `subculture` attribute within the `<Faction name="Default">` node as a fallback.
            - [x] 1.2.1.3. If the `subculture` attribute is not found in either the specific faction or the `Default` faction, the method should return an empty string or null. The calling code in `BattleFile.cs` should then display a pop-up message to the user, warning them that a subculture could not be determined and that the battle might not load correctly.
        - [x] 1.2.2. In `BattleFile.cs`, get the defender's (garrison's) culture and heritage from `Sieges.cs`.
        - [x] 1.2.3. Use the existing unit mapper to determine the defender's Attila faction name.
        - [x] 1.2.4. Call the new method to get the subculture string for that faction.
        - [x] 1.2.5. If a subculture string is returned, write it into a `<subculture>...</subculture>` tag within the `<battle_description>` section of the XML file.
    - [x] 1.3. Call a new method in `Sieges.cs` to get the final settlement level and variation (e.g., `GetSettlementBattleMap()`). This method will return the tile path (e.g., `terrain/tiles/battle/settlement_western_cities/western_city_a/medium/`) and the level upgrade tag (e.g., `<tile_upgrade>level1</tile_upgrade>`).
    - [x] 1.4. Call `Sieges.GetEscalationTileUpgrade()` to get the escalation tag (e.g., `<tile_upgrade>escalation3</tile_upgrade>`) and add it to the XML.
    - [x] 1.5. Add logic to write wall damage tags to `tut_battle.xml` based on the breach status.
        - [x] 1.5.1. Create a new method in `Sieges.cs` or `Sieges_DataTypes.cs` (e.g., `GetFortificationDamageTags()`) that takes the breach status string ("Intact", "SmallBreach", "LargeBreach") as input.
        - [x] 1.5.2. This method will return a formatted string containing `<fortification_wall_damage>`, `<fortification_building_damage>`, and `<fortification_wall_breaches>` tags.
        - [x] 1.5.3. The values should be mapped as follows:
            - **Intact:** `<fortification_wall_damage>0.0</fortification_wall_damage>`, `<fortification_wall_breaches>0</fortification_wall_breaches>`
            - **SmallBreach:** `<fortification_wall_damage>0.3</fortification_wall_damage>`, `<fortification_wall_breaches>2</fortification_wall_breaches>` (representing a couple of breaches)
            - **LargeBreach:** `<fortification_wall_damage>0.6</fortification_wall_damage>`, `<fortification_wall_breaches>4</fortification_wall_breaches>` (representing multiple, large breaches)
            - `<fortification_building_damage>` can be set to a default value like `0.25` for all cases for now.
        - [x] 1.5.4. In `BattleFile.cs`, call this new method and append the returned string to the battle file content.

- [ ] 2. **Modify `DeclarationsFile.cs`:**
    - [ ] 2.1. Add a condition: if `BattleState.IsSiegeBattle` is true, call `DeclareSiegeVariables()` to add the `DEFENDER_SUPPLY_LEVEL` declaration to the Lua file.

### Phase 3: Scripting & Finalization

- [ ] 1. **Create `tut_sieges.lua`:**
    - [ ] 1.1. Create a new Lua script file in `data\battle files\script\tut_tutorial_battle\`.
    - [ ] 1.2. This script will be responsible for applying siege-specific gameplay effects.
    - [ ] 1.3. It will read the `DEFENDER_SUPPLY_LEVEL` variable.
    - [ ] 1.4. Based on the value of this variable, it will apply morale or fatigue penalties to the defending garrison units using the Attila scripting API (e.g., `garrison_army:units():item(i):apply_fatigue(level)`).

- [ ] 2. **Update `BattleFile.cs` to reference the new script:**
    - [ ] 2.1. If `BattleState.IsSiegeBattle` is true, change the `<battle_script>` tag to point to `tut_sieges.lua` instead of the default script.

## 7. Clarifying Questions

1.  **Log Value Variations:** What are the possible string values for Wall, Supply, and Sickness states?
    *   **Answer:** The log will provide frame numbers. These map to the following English strings:
        *   **Walls:** 0="Intact", 1="SmallBreach", 2="LargeBreach"
        *   **Supplies:** 0="Fully Stocked", 1="Running Low", 2="Starvation"
        *   **Sickness:** 0="No Diseases", 1="Sickness Spreading", 2="Rampant Disease"
    *   **Note:** The application should parse the frame numbers from the log (e.g., `BreachFrame:1`) and then use an internal mapping to get these strings. This avoids issues with game localization affecting the log output.

2.  **Siege Equipment:** How is siege equipment identified?
    *   **Answer:** In the `*_Factions.xml` unit mapping files, any Men-at-Arms unit that functions as siege equipment will have a `siege="true"` attribute. The application must read these files and check this attribute for each MaA unit in the attacker's army.

3.  **Garrison Composition:** How should the garrison army be composed?
    *   **Answer:** The log provides the garrison's culture and heritage. This is sufficient to use the existing unit mapper, which translates CK3 culture/heritage into appropriate Total War: Attila factions and units. A culturally-fitting garrison army can be generated.

4.  **Do you think the siege logging in console_history.txt file identifies to the app enough that it is a siege and not a battle?**
    *   **Answer:** Yes, absolutely. The use of a unique keyword (`Keyword:CRUSADERCONFLICTS_SIEGE`) is a robust and reliable method for distinguishing battle types. As long as field battles use a different keyword (e.g., `Keyword:CRUSADERCONFLICTS_BATTLE`), there will be no ambiguity. This is the ideal way to signal the battle type to the application.

5.  **Is Crusader Kings 3 using just army units like the one you saw for ballistrai for siege equipment or are there other ways they manage siege equipment that we need to consider?**
    *   **Answer:** For the purpose of exporting a battle, considering only Men-at-Arms (MaA) units is the correct approach. In CK3, siege capability is an attribute of MaA regiments. There isn't a separate system for "building" or "deploying" siege equipment like battering rams or siege towers in the way Total War does; these concepts are abstracted into the siege progress value, which is influenced by having siege-specialist MaA. Therefore, identifying MaA units with the `siege="true"` flag from the army composition log is the complete and accurate way to determine the attacker's siege capabilities for the generated Attila battle.

6.  **How should wall damage be represented in the Attila XML file?**
    *   **Answer:** The breach status from CK3 ("Intact", "SmallBreach", "LargeBreach") will be mapped to specific XML tags in `tut_battle.xml`. This includes `<fortification_wall_damage>` (a percentage from 0.0 to 1.0) and `<fortification_wall_breaches>` (an integer count). This is separate from the visual `<tile_upgrade>escalationX</tile_upgrade>` tag. The mapping will be:
        *   **Intact:** `<fortification_wall_damage>0.0</fortification_wall_damage>`, `<fortification_wall_breaches>0</fortification_wall_breaches>`
        *   **SmallBreach:** `<fortification_wall_damage>0.3</fortification_wall_damage>`, `<fortification_wall_breaches>2</fortification_wall_breaches>`
        *   **LargeBreach:** `<fortification_wall_damage>0.6</fortification_wall_damage>`, `<fortification_wall_breaches>4</fortification_wall_breaches>`
    *   A default value will be used for `<fortification_building_damage>`.

## 8. Assumptions

1.  **Existing Code Functionality:** I assume the existing methods in `Sieges_DataTypes.cs` (e.g., `GetLevel`, `GetArchitecture`, `GetVariation`) are correct and produce valid outputs for Total War: Attila.
2.  **Data Source Hybrid Model:** I assume the siege implementation will rely on a hybrid model: the `console_history.txt` log for the *current state* of the siege (walls, supplies) and the main save file for the *static properties* of the province (full building list, culture, fort level).
3.  **Attila Engine Behavior:** I assume that correctly setting the XML tags (`<type>settlement_standard</type>`, `<tile_upgrade>`, etc.) is sufficient to make the Attila engine load the appropriate siege battle.
4.  **Mod Compatibility:** I assume that the unit mappers correctly abstract away the differences between vanilla and major overhaul mods, providing a consistent data structure for the application to use regardless of the player's mod setup.
5.  **Performance:** I assume that the additional parsing for siege data will not introduce significant performance degradation to the save file reading process.

## 9. Future Enhancements

*   **Deployable Siege Equipment:** The current implementation treats siege weapons (e.g., Onagers, Trebuchets) as standard Men-at-Arms units that are part of the army roster from the start of the battle. A future enhancement will leverage Total War: Attila's `<assault_equipment>` system. This will involve:
    *   Counting the number of siege-capable MaA units from the CK3 army.
    -   Generating `<assault_equipment_item>` entries in `tut_battle.xml` for items like battering rams and siege towers.
    -   This will allow the player to deploy these pieces of equipment at the start of the battle, providing a more authentic siege experience, as seen in the reference `siegeoflondinium.xml` file.
