# Development Plan: Attila Crash Detection and Autofix

## 1. Summary / Overview
- **Problem**: Total War: Attila frequently crashes when loading battles with custom units from the extensive unit mappers. This creates a poor user experience, forcing users to manually restart the process without a clear solution.
- **Goal**: Implement an automatic crash detection and recovery system.
- **Outcome**: When Attila crashes, the application will detect it, inform the user, and offer an iterative autofix. The system will replace one potentially problematic unit type at a time with a safe default and relaunch the battle. This targeted approach will significantly improve stability and help identify the specific custom units that are causing crashes.

## 2. Design Requirements
- The system must reliably detect when the Attila process terminates prematurely.
- Upon the first crash, the user must be presented with a clear dialog box explaining the likely cause and offering the autofix.
- The autofix process must be iterative: it should replace only one unique Attila unit key across all armies per attempt.
- The fix should not affect core units like Generals and Knights.
- If the user agrees, the battle should be regenerated and relaunched seamlessly.
- If a subsequent crash occurs during the autofix sequence, the user should not be prompted again. The system should automatically proceed to the next unit type.
- The system must prevent infinite loops if the autofix process itself fails after all potential units have been replaced.

## 3. Design Specification
- **File to Modify**: `CrusaderWars\twbattle\BattleProcessor.cs`
- **New Helper Class**: A private class `AutofixState` will be defined within `BattleProcessor.cs` to manage the iterative fix process.
    - `public List<string> ProblematicUnitKeys { get; set; }` // A list of unique Attila unit keys to test.
    - `public int NextKeyIndexToReplace { get; set; }` // The index of the next key in the list to replace.
- **Method to Modify**: `ProcessBattle` signature will be updated to `ProcessBattle(..., AutofixState? autofixState = null)`.
- **Logic Flow**:
    1.  The `while (battleEnded == false)` loop detects a crash when `Process.GetProcessesByName("Attila").Length == 0`.
    2.  **If `autofixState` is `null` (First Crash):**
        - Show the `MessageBox` to the user asking if they want to attempt an autofix.
        - If "No", log the choice and return `false`.
        - If "Yes":
            - Create a new `AutofixState` instance.
            - Scan all `Unit` objects in both `attacker_armies` and `defender_armies`.
            - Compile a list of unique, non-default, non-character `AttilaUnitKey`s and store it in `autofixState.ProblematicUnitKeys`.
            - If the list is empty, inform the user the crash is likely not due to a mappable unit and return `false`.
            - Log the list of potentially problematic keys that will be tested.
    3.  **If `autofixState` is not `null` (Subsequent Crash):**
        - The process continues automatically without a user prompt.
    4.  **Common Autofix Logic (for all crashes in the sequence):**
        - Check if `autofixState.NextKeyIndexToReplace` has exceeded the bounds of the `ProblematicUnitKeys` list. If so, the autofix has failed. Inform the user and return `false`.
        - Get the `keyToReplace` from the `ProblematicUnitKeys` list at the current index.
        - Log the `keyToReplace` that is being targeted in this attempt.
        - Call a new helper method `ApplyTargetedUnitFix(List<Army> armies, string keyToReplace)`. This method will iterate through all units and replace any unit whose `AttilaUnitKey` matches `keyToReplace` with a safe default from `UnitMappers_BETA.GetDefaultUnitKey()`.
        - Increment `autofixState.NextKeyIndexToReplace`.
        - Recursively call `ProcessBattle(..., autofixState)` to regenerate the battle files and relaunch Attila.

## 4. Implementation Steps
- [x] 1. Modify `CrusaderWars\twbattle\BattleProcessor.cs`.
- [x] 1.1. Define a new private class `AutofixState` inside `BattleProcessor.cs` with properties `List<string> ProblematicUnitKeys` and `int NextKeyIndexToReplace`.
- [x] 1.2. Change the `ProcessBattle` method signature to accept an optional `AutofixState? autofixState = null` parameter.
- [x] 1.3. Locate the `if (Process.GetProcessesByName("Attila").Length == 0)` block.
- [x] 1.4. **First Crash Logic (`autofixState == null`):**
    - [x] 1.4.1. Implement the user prompt `MessageBox`. If the user chooses "No", `return false`.
    - [x] 1.4.2. If "Yes", create a new `AutofixState`.
    - [x] 1.4.3. Collect all unique `AttilaUnitKey`s from `MenAtArms`, `Levy`, and `Garrison` units across all armies. Exclude empty or `not_found` keys.
    - [x] 1.4.4. Populate `autofixState.ProblematicUnitKeys` with this list.
    - [x] 1.4.5. If the list is empty, show a message to the user that no problematic units were found and `return false`.
- [x] 1.5. **Subsequent Crash Logic (`autofixState != null`):**
    - [x] 1.5.1. This block will be entered directly on subsequent crashes, skipping the user prompt.
- [x] 1.6. **Implement Common Autofix Logic:**
    - [x] 1.6.1. Check if `autofixState.NextKeyIndexToReplace >= autofixState.ProblematicUnitKeys.Count`. If true, show a message that the autofix failed after trying all units, and `return false`.
    - [x] 1.6.2. Get the `keyToReplace` from `autofixState.ProblematicUnitKeys[autofixState.NextKeyIndexToReplace]`.
    - [x] 1.6.3. Log the key being replaced.
    - [x] 1.6.4. Iterate through all units in `attacker_armies` and `defender_armies`. If a unit's key matches `keyToReplace`, log the change and update its key using `unit.SetUnitKey(UnitMappers_BETA.GetDefaultUnitKey(...))`.
    - [x] 1.6.5. Increment `autofixState.NextKeyIndexToReplace`.
    - [x] 1.6.6. Recursively call `ProcessBattle(form, attacker_armies, defender_armies, token, true, autofixState)`.
    - [x] 1.6.7. Return the result of the recursive call.

## 5. Clarifying Questions
- The user has confirmed the need to prevent infinite loops, which is handled by the `AutofixState` index tracking. No further questions at this time.

## 6. Feedback and Iteration
- This plan incorporates user feedback to switch from a "replace all" strategy to a more targeted, iterative "replace one type at a time" strategy. This is managed via a new `AutofixState` class passed through recursive calls.

## 7. Assumptions
- The `UnitMappers_BETA.GetDefaultUnitKey()` method will consistently return a valid, non-crashing unit key.
- Crashes are primarily caused by `MenAtArms`, `Levy`, or `Garrison` unit models, and not by `Commander` or `Knight` units.
- The crash occurs while the application is waiting for the Attila battle to complete, not during the initial file generation phase.
